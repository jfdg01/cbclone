


public abstract class BaseScreen implements Screen {
    protected MyAssetManager assetManager;
    protected AudioManager audioManager;
    protected SpineAnimationHandler spineAnimationHandler;
    protected ConfigurationManager configManager;
    protected ScreenManager screenManager;
    private SnapshotArray<TrailDot> trailDots;
    private int trailDotCount = 0;
    private SpriteBatch batch;
    private Camera camera;
    private Viewport viewport;
    private Stage stage;

    public BaseScreen(SpineAnimationHandler spineAnimationHandler, ScreenManager screenManager) {
        this.assetManager = MyAssetManager.getInstance();
        this.audioManager = AudioManager.getInstance();
        this.configManager = ConfigurationManager.getInstance();
        this.spineAnimationHandler = spineAnimationHandler;
        this.screenManager = screenManager;

        // Initialize camera and viewport
        this.viewport = new ExtendViewport(Constants.General.WIDTH, Constants.General.HEIGHT);
        this.camera = viewport.getCamera();

        this.stage = new Stage(viewport);
        this.trailDots = new SnapshotArray<TrailDot>();
        this.batch = new SpriteBatch();

        Gdx.input.setInputProcessor(stage);

        stage.addListener(new InputListener() {
            @Override
            public boolean mouseMoved(InputEvent event, float x, float y) {
                createTrailDot(x, y);
                Gdx.app.log("BaseScreen", "Mouse moved at x=" + x + " y=" + y);
                return true;
            }
        });
    }

    @Override
    public void show() {

    }

    public void clearScreen() {
        Gdx.gl.glClearColor(0, 0, 0, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
    }

    @Override
    public void render(float delta) {
        clearScreen();
    }

    void renderTrail(float delta, SpriteBatch batch) {
        batch.setProjectionMatrix(viewport.getCamera().combined);
        Iterator<TrailDot> iterator = trailDots.iterator();
        while (iterator.hasNext()) {
            TrailDot trailDot = iterator.next();
            trailDot.state.update(delta);
            trailDot.state.apply(trailDot.skeleton);
            trailDot.skeleton.updateWorldTransform();
            trailDot.skeleton.setPosition(trailDot.x, trailDot.y);

            trailDot.renderer.draw(batch, trailDot.skeleton);

            if (trailDot.state.getCurrent(0) == null || trailDot.state.getCurrent(0).isComplete()) {
                iterator.remove();
            }
        }
    }

    @Override
    public void resize(int width, int height) {
        viewport.update(width, height);
        camera.position.set(camera.viewportWidth / 2, camera.viewportHeight / 2, 0);
        stage.getViewport().update(width, height, true);
        Gdx.app.log("BaseScreen", "Resize: width=" + width + " height=" + height);
        Gdx.app.log("BaseScreen", "Camera position: x=" + camera.position.x + " y=" + camera.position.y);
        Gdx.app.log("BaseScreen", "Viewport: worldWidth=" + viewport.getWorldWidth() + " worldHeight=" + viewport.getWorldHeight() + " screenWidth=" + viewport.getScreenWidth() + " screenHeight=" + viewport.getScreenHeight());
        Gdx.app.log("BaseScreen", "Stage: width=" + stage.getWidth() + " height=" + stage.getHeight());
    }

    @Override
    public void pause() {
        // Override in subclasses if needed
    }

    @Override
    public void resume() {
        // Override in subclasses if needed
    }

    @Override
    public void hide() {
        // Override in subclasses to hide the screen
    }

    @Override
    public void dispose() {
        stage.dispose();
        if (batch != null) {
            batch.dispose();
        }
    }

    private void createTrailDot(float x, float y) {
        float hue = (trailDotCount % Constants.TrailDot.NUMBER_OF_COLORS);

        Color currentColor = new Color();
        currentColor.fromHsv(hue, Constants.TrailDot.SATURATION, Constants.TrailDot.VALUE);
        currentColor.a = Constants.TrailDot.ALPHA;

        String trailAtlasPath = Constants.TrailDot.ATLAS;
        String trailSkeletonPath = Constants.TrailDot.JSON;

        Skeleton trailSkeleton = spineAnimationHandler.createSkeleton(trailAtlasPath, trailSkeletonPath);
        AnimationState trailState = spineAnimationHandler.createAnimationState(trailSkeleton);
        SkeletonRenderer trailRenderer = new SkeletonRenderer();
        trailRenderer.setPremultipliedAlpha(true);

        float randomScale = MathUtils.random(Constants.TrailDot.MIN_SCALE, Constants.TrailDot.MAX_SCALE);
        float randomRotation = MathUtils.random(Constants.TrailDot.MIN_ROTATION, Constants.TrailDot.MAX_ROTATION);

        trailSkeleton.setPosition(x, y);
        trailSkeleton.setColor(currentColor);
        trailSkeleton.setScale(randomScale, randomScale);
        trailSkeleton.getRootBone().setRotation(randomRotation);

        trailState.setAnimation(0, "animation", false);

        trailDots.add(new TrailDot(trailSkeleton, trailState, trailRenderer, x, y));
        trailDotCount++;
    }

    private static class TrailDot {
        public Skeleton skeleton;
        public AnimationState state;
        public SkeletonRenderer renderer;
        public float x, y;

        public TrailDot(Skeleton skeleton, AnimationState state, SkeletonRenderer renderer, float x, float y) {
            this.skeleton = skeleton;
            this.state = state;
            this.renderer = renderer;
            this.x = x;
            this.y = y;
        }
    }

    protected void setSkeletonScale(Skeleton skeleton, float widthPercentage, float heightPercentage) {
        if (skeleton != null) {
            float screenWidth = viewport.getWorldWidth();
            float screenHeight = viewport.getWorldHeight();

            float skeletonWidth = screenWidth * widthPercentage;
            float skeletonHeight = screenHeight * heightPercentage;

            float scaleX = skeletonWidth / skeleton.getData().getWidth();
            float scaleY = skeletonHeight / skeleton.getData().getHeight();

            float scale = Math.min(scaleX, scaleY);

            skeleton.setScale(scale, scale);
            Gdx.app.log("BaseScreen", skeleton.getData().getName() + " skeleton scale set to " + scale);
        }
    }

    protected void setSkeletonPosition(Skeleton skeleton, float x, float y) {
        if (skeleton != null) {
            skeleton.setPosition(x, y);
            Gdx.app.log("BaseScreen", skeleton.getData().getName() + " skeleton position set to x=" + x + " y=" + y);
        }
    }

    public Stage getStage() {
        return stage;
    }
}




public class ConfigurationScreen extends BaseScreen {
    private Slider volumeSlider;
    private TextButton backButton;
    private TextButton hairColorButton;
    private TextButton coinColorButton;
    private HairColor currentHairColor;
    private boolean isYellowCoin;
    private Stage stage;
    private Viewport viewport;
    private SpriteBatch batch;

    public ConfigurationScreen(SpineAnimationHandler spineAnimationHandler, ScreenManager screenManager) {
        super(spineAnimationHandler, screenManager);
        this.screenManager = screenManager;
    }

    @Override
    public void show() {
        super.show();

        viewport = new ScreenViewport();
        stage = new Stage(viewport);
        batch = new SpriteBatch();

        Skin skin = assetManager.get(Constants.Skin.JSON, Skin.class);
        float savedVolume = configManager.getPreference("volume", Constants.Audio.DEFAULT_VOLUME);
        String savedHairColor = configManager.getPreference("hairColor", HairColor.BLONDE.toString());
        isYellowCoin = configManager.getPreference("coinColor", true);

        currentHairColor = HairColor.valueOf(savedHairColor);

        volumeSlider = new Slider(0, 1, 0.01f, false, skin);
        volumeSlider.setValue(savedVolume);
        volumeSlider.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                float volume = volumeSlider.getValue();
                audioManager.setVolume(volume);
                configManager.setPreference("volume", volume);
            }
        });

        backButton = new TextButton("Back", skin, Constants.Font.BUTTON);
        backButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                screenManager.setScreen(ScreenType.MENU);
            }
        });

        hairColorButton = new TextButton("Hair Color: " + currentHairColor, skin, Constants.Font.BUTTON);
        hairColorButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                currentHairColor = currentHairColor.next();
                hairColorButton.setText("Hair Color: " + currentHairColor);
                configManager.setPreference("hairColor", currentHairColor.toString());
            }
        });

        coinColorButton = new TextButton("Coin Color: " + (isYellowCoin ? "Yellow" : "Red"), skin, Constants.Font.BUTTON);
        coinColorButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                isYellowCoin = !isYellowCoin;
                coinColorButton.setText("Coin Color: " + (isYellowCoin ? "Yellow" : "Red"));
                configManager.setPreference("coinColor", isYellowCoin);
            }
        });

        Table table = new Table();
        table.setFillParent(true);
        table.center();
        table.add(new Label("Options", skin, Constants.Font.LABEL)).padBottom(Constants.UIButtons.PADDING).row();
        table.add(new Label("Volume", skin, Constants.Font.LABEL)).padBottom(Constants.UIButtons.PADDING).row();
        table.add(volumeSlider).width(Constants.UIButtons.SLIDER_WIDTH).padBottom(Constants.UIButtons.PADDING).row();
        table.add(hairColorButton).width(Constants.UIButtons.CONTROL_BUTTON_WIDTH).height(Constants.UIButtons.CONTROL_BUTTON_HEIGHT).padBottom(Constants.UIButtons.PADDING).row();
        table.add(coinColorButton).width(Constants.UIButtons.CONTROL_BUTTON_WIDTH).height(Constants.UIButtons.CONTROL_BUTTON_HEIGHT).padBottom(Constants.UIButtons.PADDING).row();
        table.add(backButton).width(Constants.UIButtons.BACK_BUTTON_WIDTH).height(Constants.UIButtons.CONTROL_BUTTON_HEIGHT).padTop(Constants.UIButtons.PADDING);

        stage.addActor(table);

        viewport.update(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);
        stage.getViewport().update(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);
    }

    @Override
    public void render(float delta) {
        super.render(delta);

        viewport.apply();
        batch.setProjectionMatrix(viewport.getCamera().combined);

        batch.begin();
        stage.act(delta);
        stage.draw();
        renderTrail(delta, batch);
        batch.end();
    }

    @Override
    public void resize(int width, int height) {
        super.resize(width, height);
        viewport.update(width, height, true);
        stage.getViewport().update(width, height, true);
    }

    @Override
    public void dispose() {
        super.dispose();
    }
}





public class MainAnimationScreen extends BaseScreen {
    private SkeletonRenderer renderer;
    private SpineAnimationHandler spineAnimationHandler;
    private Skeleton coinSkeleton;
    private AnimationState coinState;
    private Skeleton buttonSkeleton;
    private AnimationState buttonState;
    private boolean isYellowCoin;
    private TextButton backButton;
    private Slider slider;
    private TextButton modeButton;
    private TextButton changeCoinColorButton;
    private boolean isLooping = true;
    private float speedMultiplier = 1f;
    private float lastSliderValue = 0f;
    private HashMap<String, Boolean> hoverStates;
    private ShapeRenderer shapeRenderer;
    private Texture backgroundTexture;
    private TextButton swapSkinsButton;  // New button to swap skins
    private Stage stage;
    private Camera camera;
    private Viewport mainViewport;
    private SpriteBatch batch;

    public MainAnimationScreen(SpineAnimationHandler spineAnimationHandler, ScreenManager screenManager) {
        super(spineAnimationHandler, screenManager);
        this.spineAnimationHandler = spineAnimationHandler;
    }

    @Override
    public void show() {
        mainViewport = new FitViewport(Constants.General.WIDTH, Constants.General.HEIGHT);
        camera = mainViewport.getCamera();
        stage = new Stage(mainViewport);
        batch = new SpriteBatch();

        renderer = new SkeletonRenderer();
        renderer.setPremultipliedAlpha(true);
        backgroundTexture = assetManager.get(Constants.Background.PATH, Texture.class);

        shapeRenderer = new ShapeRenderer();

        isYellowCoin = configManager.getPreference("coinColor", true);
        initializeCoinAnimations(0f);
        initializeButtonAnimations();

        Skin skin = assetManager.get(Constants.Skin.JSON, Skin.class);

        backButton = new TextButton("Back to Menu", skin, Constants.Font.BUTTON);
        backButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                screenManager.setScreen(ScreenType.MENU);
            }
        });

        slider = new Slider(0, 1, 0.01f, false, skin);
        slider.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                if (!isLooping) {
                    float progress = slider.getValue();
                    float animationDuration = coinState.getCurrent(0).getAnimation().getDuration();
                    coinState.getCurrent(0).setTrackTime(progress * animationDuration);
                    if (progress != lastSliderValue) {
                        lastSliderValue = progress;
                        System.out.println("Slider changed: " + slider.getValue() + " Mode: Manual");
                    }
                }
            }
        });

        modeButton = new TextButton("Switch to Manual Mode", skin, Constants.Font.BUTTON);
        modeButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                isLooping = !isLooping;
                System.out.println("Mode changed to: " + (isLooping ? "Automatic" : "Manual"));
                if (isLooping) {
                    modeButton.setText("Switch to Manual Mode");
                    coinState.setAnimation(0, "animation", true);
                } else {
                    modeButton.setText("Switch to Automatic Mode");
                }
            }
        });

        changeCoinColorButton = new TextButton("Change Coin Color", skin, Constants.Font.BUTTON);
        changeCoinColorButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                toggleCoinColor();
            }
        });

        swapSkinsButton = new TextButton("Swap Skins", skin, Constants.Font.BUTTON);
        swapSkinsButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                swapSkins();
            }
        });

        Table bottomTable = new Table();
        bottomTable.setFillParent(true);
        bottomTable.bottom();
        bottomTable.add(slider).width(Constants.UIButtons.SLIDER_WIDTH).padBottom(Constants.UIButtons.PADDING);
        bottomTable.row();
        bottomTable.add(modeButton).padBottom(Constants.UIButtons.PADDING);

        Table backButtonTable = new Table();
        backButtonTable.setFillParent(true);
        backButtonTable.bottom().left();
        backButtonTable.add(backButton).width(Constants.UIButtons.BACK_BUTTON_WIDTH).height(Constants.UIButtons.CONTROL_BUTTON_HEIGHT).pad(Constants.UIButtons.PADDING);

        Table topTable = new Table();
        topTable.setFillParent(true);
        topTable.top();
        topTable.add(changeCoinColorButton).pad(Constants.UIButtons.PADDING);
        topTable.row();
        topTable.add(swapSkinsButton).pad(Constants.UIButtons.PADDING);  // Add the new button to the layout

        stage.addActor(bottomTable);
        stage.addActor(backButtonTable);
        stage.addActor(topTable);

        hoverStates = new HashMap<String, Boolean>();
        hoverStates.put(Constants.MainAnimationScreen.BUTTON_1X_NAME, false);
        hoverStates.put(Constants.MainAnimationScreen.BUTTON_2X_NAME, false);
        hoverStates.put(Constants.MainAnimationScreen.BUTTON_3X__NAME, false);

        stage.addListener(new InputListener() {
            @Override
            public boolean mouseMoved(InputEvent event, float x, float y) {
                handleHover(x, y);
                return true;
            }

            @Override
            public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
                handleClick(x, y);
                return true;
            }
        });

        mainViewport.update(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);
        stage.getViewport().update(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);
    }

    private void toggleCoinColor() {
        float currentStateTime = coinState.getCurrent(0).getTrackTime();
        isYellowCoin = !isYellowCoin;
        configManager.setPreference("coinColor", isYellowCoin);
        initializeCoinAnimations(currentStateTime);
    }

    private void initializeCoinAnimations(float stateTime) {
        String atlasPath = isYellowCoin ? Constants.MainAnimationScreen.YellowCoin.ATLAS : Constants.MainAnimationScreen.RedCoin.ATLAS;
        String skeletonPath = isYellowCoin ? Constants.MainAnimationScreen.YellowCoin.JSON : Constants.MainAnimationScreen.RedCoin.JSON;
        coinSkeleton = spineAnimationHandler.createSkeleton(atlasPath, skeletonPath);
        coinState = spineAnimationHandler.createAnimationState(coinSkeleton);

        setSkeletonScale(coinSkeleton, Constants.MainAnimationScreen.COIN_WIDTH_PERCENTAGE, Constants.MainAnimationScreen.COIN_HEIGHT_PERCENTAGE);  // Adjust the percentages as needed
        setSkeletonPosition(coinSkeleton, mainViewport.getWorldWidth() / 2, mainViewport.getWorldHeight() / 2);

        coinState.setAnimation(0, "animation", true);
        coinState.getCurrent(0).setTrackTime(stateTime);
        coinState.addListener(new AnimationState.AnimationStateAdapter() {
            @Override
            public void complete(AnimationState.TrackEntry entry) {
                System.out.println("Animation completed");
            }
        });
    }

    private void initializeButtonAnimations() {
        String atlasPath = Constants.MainAnimationScreen.ATLAS;
        String skeletonPath = Constants.MainAnimationScreen.JSON;

        buttonSkeleton = spineAnimationHandler.createSkeleton(atlasPath, skeletonPath);
        buttonState = spineAnimationHandler.createAnimationState(buttonSkeleton);

        setSkeletonScale(buttonSkeleton, Constants.MainAnimationScreen.BUTTONS_WIDTH_PERCENTAGE, Constants.MainAnimationScreen.BUTTONS_HEIGHT_PERCENTAGE);  // Adjust the percentages as needed
        setSkeletonPosition(buttonSkeleton, 0, mainViewport.getWorldHeight());

        playButtonPressAnimation(Constants.MainAnimationScreen.BUTTON_1X_NAME, "1x/pressed", 1f);
    }

    private void handleHover(float x, float y) {
        updateHoverState(x, y, Constants.MainAnimationScreen.BUTTON_1X_NAME, 1, "1x/hoverIn", "1x/hoverOut");
        updateHoverState(x, y, Constants.MainAnimationScreen.BUTTON_2X_NAME, 2, "2x/hoverIn", "2x/hoverOut");
        updateHoverState(x, y, Constants.MainAnimationScreen.BUTTON_3X__NAME, 3, "3x/hoverIn", "3x/hoverOut");
    }

    private void updateHoverState(float x, float y, String buttonName, int trackIndex, String hoverInAnim, String hoverOutAnim) {
        boolean isHovered = isHoveringButton(x, y, buttonName);
        boolean wasHovered = hoverStates.get(buttonName);

        if (isHovered && !wasHovered) {
            buttonState.setAnimation(trackIndex, hoverInAnim, false);
        } else if (!isHovered && wasHovered) {
            buttonState.setAnimation(trackIndex, hoverOutAnim, false);
        }

        hoverStates.put(buttonName, isHovered);
    }

    private void swapSkins() {
        String currentSkin = buttonSkeleton.getSkin().getName();
        String newSkin = currentSkin.equals("Saturated") ? "Accessible" : "Saturated";
        buttonSkeleton.setSkin(newSkin);
    }

    private void handleClick(float x, float y) {
        if (isHoveringButton(x, y, Constants.MainAnimationScreen.BUTTON_1X_NAME)) {
            playButtonPressAnimation(Constants.MainAnimationScreen.BUTTON_1X_NAME, "1x/pressed", 1f);
        } else if (isHoveringButton(x, y, Constants.MainAnimationScreen.BUTTON_2X_NAME)) {
            playButtonPressAnimation(Constants.MainAnimationScreen.BUTTON_2X_NAME, "2x/pressed", 2f);
        } else if (isHoveringButton(x, y, Constants.MainAnimationScreen.BUTTON_3X__NAME)) {
            playButtonPressAnimation(Constants.MainAnimationScreen.BUTTON_3X__NAME, "3x/pressed", 3f);
        }
    }

    private void playButtonPressAnimation(String buttonName, final String animationName, final float speed) {
        Gdx.app.log("MainAnimationScreen", "Playing button press animation: " + animationName);
        buttonState.setAnimation(4, animationName, false).setListener(new AnimationState.AnimationStateListener() {
            @Override
            public void start(AnimationState.TrackEntry entry) {
            }

            @Override
            public void interrupt(AnimationState.TrackEntry entry) {
            }

            @Override
            public void end(AnimationState.TrackEntry entry) {
            }

            @Override
            public void dispose(AnimationState.TrackEntry entry) {
            }

            @Override
            public void complete(AnimationState.TrackEntry entry) {
                Gdx.app.log("MainAnimationScreen", "Animation complete: " + animationName);
                speedMultiplier = speed;
            }

            @Override
            public void event(AnimationState.TrackEntry entry, Event event) {
            }
        });
    }

    private boolean isHoveringButton(float x, float y, String buttonName) {
        Rectangle buttonBounds = getButtonBounds(buttonName);
        return buttonBounds.contains(x, y);
    }

    private Rectangle getButtonBounds(String buttonName) {
        String bgSlotName = "bg-" + buttonName;
        Bone bone = buttonSkeleton.findBone(buttonName);
        if (bone == null) return new Rectangle();

        Slot slot = buttonSkeleton.findSlot(bgSlotName);  // Use the background slot
        if (slot == null || !(slot.getAttachment() instanceof RegionAttachment)) return new Rectangle();

        RegionAttachment attachment = (RegionAttachment) slot.getAttachment();
        if (attachment == null) return new Rectangle();

        float[] vertices = new float[8];
        attachment.computeWorldVertices(slot.getBone(), vertices, 0, 2);

        float minX = vertices[0];
        float minY = vertices[1];
        float maxX = vertices[0];
        float maxY = vertices[1];

        for (int i = 2; i < vertices.length; i += 2) {
            if (vertices[i] < minX) minX = vertices[i];
            if (vertices[i + 1] < minY) minY = vertices[i + 1];
            if (vertices[i] > maxX) maxX = vertices[i];
            if (vertices[i + 1] > maxY) maxY = vertices[i + 1];
        }

        return new Rectangle(minX, minY, maxX - minX, maxY - minY);
    }

    @Override
    public void render(float delta) {
        clearScreen();

        if (isLooping) {
            coinState.update(delta * speedMultiplier);
        }

        coinState.apply(coinSkeleton);
        coinSkeleton.updateWorldTransform();

        buttonState.update(delta);
        buttonState.apply(buttonSkeleton);
        buttonSkeleton.updateWorldTransform();

        mainViewport.apply();
        batch.setProjectionMatrix(camera.combined);

        batch.begin();
        batch.draw(backgroundTexture, 0, 0, mainViewport.getWorldWidth(), mainViewport.getWorldHeight());
        // Draw the coin animation
        renderer.draw(batch, coinSkeleton);
        // Draw the button animations
        renderer.draw(batch, buttonSkeleton);
        // Draw the UI
        stage.act(delta);
        stage.draw();
        // Draw the trail
        super.renderTrail(delta, batch);
        batch.end();

        // Render debug bounds
        // renderDebug();
    }

    private void renderDebug() {
        shapeRenderer.setProjectionMatrix(camera.combined);
        shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
        shapeRenderer.setColor(Color.RED);
        drawDebugBounds(Constants.MainAnimationScreen.BUTTON_1X_NAME);
        drawDebugBounds(Constants.MainAnimationScreen.BUTTON_2X_NAME);
        drawDebugBounds(Constants.MainAnimationScreen.BUTTON_3X__NAME);
        shapeRenderer.end();
    }

    private void drawDebugBounds(String buttonName) {
        Rectangle bounds = getButtonBounds(buttonName);
        shapeRenderer.rect(bounds.x, bounds.y, bounds.width, bounds.height);
    }

    @Override
    public void resize(int width, int height) {
        super.resize(width, height);
        mainViewport.update(width, height, true);
        stage.getViewport().update(width, height, true);

        setSkeletonScale(coinSkeleton, Constants.MainAnimationScreen.COIN_WIDTH_PERCENTAGE, Constants.MainAnimationScreen.COIN_HEIGHT_PERCENTAGE);  // Adjust the percentages as needed
        setSkeletonPosition(coinSkeleton, mainViewport.getWorldWidth() / 2, mainViewport.getWorldHeight() / 2);

        setSkeletonScale(buttonSkeleton, Constants.MainAnimationScreen.BUTTONS_WIDTH_PERCENTAGE, Constants.MainAnimationScreen.BUTTONS_HEIGHT_PERCENTAGE);  // Adjust the percentages as needed
        setSkeletonPosition(buttonSkeleton, 0, mainViewport.getWorldHeight());
    }

    @Override
    public void dispose() {
        super.dispose();
        shapeRenderer.dispose();
    }
}




public class MainMenuScreen extends BaseScreen {
    private SkeletonRenderer renderer;
    private Skeleton skeleton;
    private AnimationState state;
    private BitmapFont font;
    private Map<String, Boolean> hoverStates;
    private Texture backgroundTexture;
    private ShapeRenderer shapeRenderer;
    private boolean isInitialAnimationFinished = false;
    private Viewport mainViewport;
    private Viewport backgroundViewport;
    private SpriteBatch batch;
    private Stage stage;

    public MainMenuScreen(SpineAnimationHandler spineAnimationHandler, ScreenManager screenManager) {
        super(spineAnimationHandler, screenManager);
    }

    @Override
    public void show() {
        super.show();

        mainViewport = new FitViewport(Constants.General.WIDTH, Constants.General.HEIGHT);
        backgroundViewport = new ExtendViewport(Constants.General.WIDTH, Constants.General.HEIGHT);
        batch = new SpriteBatch();

        renderer = new SkeletonRenderer();
        renderer.setPremultipliedAlpha(true);

        initializeAnimations();

        font = new BitmapFont();
        backgroundTexture = assetManager.get(Constants.Background.PATH, Texture.class);
        shapeRenderer = new ShapeRenderer();

        hoverStates = new HashMap<String, Boolean>();
        hoverStates.put(Constants.MainMenuScreen.BUTTON_PLAY_NAME, false);
        hoverStates.put(Constants.MainMenuScreen.BUTTON_QUIT_NAME, false);
        hoverStates.put(Constants.MainMenuScreen.BUTTON_SETTINGS_NAME, false);

        stage = new Stage(mainViewport, batch);
        stage.addListener(new InputListener() {
            @Override
            public boolean mouseMoved(InputEvent event, float x, float y) {
                if (isInitialAnimationFinished) {
                    handleHover(x, y);
                }
                return true;
            }

            @Override
            public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
                handleClick(x, y);
                return true;
            }
        });

        InputMultiplexer multiplexer = new InputMultiplexer();
        multiplexer.addProcessor(stage);
        Gdx.input.setInputProcessor(multiplexer);
    }

    private void initializeAnimations() {
        String atlasPath = Constants.MainMenuScreen.ATLAS;
        String skeletonPath = Constants.MainMenuScreen.JSON;

        skeleton = spineAnimationHandler.createSkeleton(atlasPath, skeletonPath);
        state = spineAnimationHandler.createAnimationState(skeleton);

        setSkeletonScale(skeleton, Constants.MainMenuScreen.SKEL_WIDTH_PERCENTAGE, Constants.MainMenuScreen.SKEL_HEIGHT_PERCENTAGE); // Adjust the percentages as needed
        setSkeletonPosition(skeleton, mainViewport.getWorldWidth() / 2, mainViewport.getWorldHeight() / 2);
        state.setAnimation(0, "animation", false);

        state.addListener(new AnimationState.AnimationStateListener() {
            @Override
            public void start(AnimationState.TrackEntry entry) {
            }

            @Override
            public void interrupt(AnimationState.TrackEntry entry) {
            }

            @Override
            public void end(AnimationState.TrackEntry entry) {
            }

            @Override
            public void dispose(AnimationState.TrackEntry entry) {
            }

            @Override
            public void complete(AnimationState.TrackEntry entry) {
                if (entry.getAnimation().getName().equals("animation")) {
                    isInitialAnimationFinished = true;
                }
            }

            @Override
            public void event(AnimationState.TrackEntry entry, Event event) {
            }
        });
    }

    private void handleHover(float x, float y) {
        updateHoverState(x, y, Constants.MainMenuScreen.BUTTON_PLAY_NAME, 1, "Buttons/PlayHoverIn", "Buttons/PlayHoverOut");
        updateHoverState(x, y, Constants.MainMenuScreen.BUTTON_QUIT_NAME, 2, "Buttons/QuitHoverIn", "Buttons/QuitHoverOut");
        updateHoverState(x, y, Constants.MainMenuScreen.BUTTON_SETTINGS_NAME, 3, "Buttons/SettingsHoverIn", "Buttons/SettingsHoverOut");
    }

    private void updateHoverState(float x, float y, String buttonName, int trackIndex, String hoverInAnim, String hoverOutAnim) {
        boolean isHovered = isHoveringButton(x, y, buttonName);
        boolean wasHovered = hoverStates.get(buttonName);

        if (isHovered && !wasHovered) {
            state.setAnimation(trackIndex, hoverInAnim, false);
        } else if (!isHovered && wasHovered) {
            state.setAnimation(trackIndex, hoverOutAnim, false);
        }

        hoverStates.put(buttonName, isHovered);
    }

    private void handleClick(float x, float y) {
        if (isHoveringButton(x, y, Constants.MainMenuScreen.BUTTON_PLAY_NAME)) {
            playButtonPressAnimation(Constants.MainMenuScreen.BUTTON_PLAY_NAME, "Buttons/PlayPress", ScreenType.GAME);
        } else if (isHoveringButton(x, y, Constants.MainMenuScreen.BUTTON_QUIT_NAME)) {
            playButtonPressAnimation(Constants.MainMenuScreen.BUTTON_QUIT_NAME, "Buttons/QuitPress", null);
        } else if (isHoveringButton(x, y, Constants.MainMenuScreen.BUTTON_SETTINGS_NAME)) {
            playButtonPressAnimation(Constants.MainMenuScreen.BUTTON_SETTINGS_NAME, "Buttons/SettingsPress", ScreenType.OPTIONS);
        }
    }

    private void playButtonPressAnimation(String buttonName, final String animationName, final ScreenType screenType) {
        Gdx.app.log("MainMenuScreen", "Playing button press animation: " + animationName);
        state.setAnimation(4, animationName, false).setListener(new AnimationState.AnimationStateListener() {
            @Override
            public void start(AnimationState.TrackEntry entry) {
            }

            @Override
            public void interrupt(AnimationState.TrackEntry entry) {
            }

            @Override
            public void end(AnimationState.TrackEntry entry) {
            }

            @Override
            public void dispose(AnimationState.TrackEntry entry) {
            }

            @Override
            public void complete(AnimationState.TrackEntry entry) {
                Gdx.app.log("MainMenuScreen", "Animation complete: " + animationName);
                if (screenType != null) {
                    Gdx.app.postRunnable(new Runnable() {
                        @Override
                        public void run() {
                            Gdx.app.log("MainMenuScreen", "Changing screen to: " + screenType);
                            screenManager.setScreen(screenType);
                        }
                    });
                } else {
                    Gdx.app.exit();
                }
            }

            @Override
            public void event(AnimationState.TrackEntry entry, Event event) {
            }
        });
    }

    private boolean isHoveringButton(float x, float y, String buttonName) {
        Rectangle buttonBounds = getButtonBounds(buttonName);
        return buttonBounds.contains(x, y);
    }

    private Rectangle getButtonBounds(String buttonName) {
        Bone bone = skeleton.findBone(buttonName);
        if (bone == null) return new Rectangle();

        Slot slot = skeleton.findSlot(buttonName);
        if (slot == null || !(slot.getAttachment() instanceof RegionAttachment)) return new Rectangle();

        RegionAttachment attachment = (RegionAttachment) slot.getAttachment();
        if (attachment == null) return new Rectangle();

        float[] vertices = new float[8];
        attachment.computeWorldVertices(slot.getBone(), vertices, 0, 2);

        float minX = vertices[0];
        float minY = vertices[1];
        float maxX = vertices[0];
        float maxY = vertices[1];

        for (int i = 2; i < vertices.length; i += 2) {
            if (vertices[i] < minX) minX = vertices[i];
            if (vertices[i + 1] < minY) minY = vertices[i + 1];
            if (vertices[i] > maxX) maxX = vertices[i];
            if (vertices[i + 1] > maxY) maxY = vertices[i + 1];
        }

        return new Rectangle(minX, minY, maxX - minX, maxY - minY);
    }

    @Override
    public void render(float delta) {
        clearScreen();

        state.update(delta);
        state.apply(skeleton);
        skeleton.updateWorldTransform();
        // super.getStage().act();

        // Render background
        backgroundViewport.apply();
        batch.setProjectionMatrix(backgroundViewport.getCamera().combined);
        batch.begin();
        batch.draw(backgroundTexture, 0, 0, backgroundViewport.getWorldWidth(), backgroundViewport.getWorldHeight());
        batch.end();

        // Render content
        mainViewport.apply();
        batch.setProjectionMatrix(mainViewport.getCamera().combined);
        batch.begin();
        renderer.draw(batch, skeleton);
        super.renderTrail(delta, batch);
        batch.end();

//        setSkeletonPosition(skeleton, viewport.getWorldWidth() / 2, viewport.getWorldHeight() / 2);
//        Gdx.app.log("MainMenuScreen", "Render: Skeleton position x=" + skeleton.getX() + " y=" + skeleton.getY());
    }

    private void renderDebug() {
        shapeRenderer.setProjectionMatrix(mainViewport.getCamera().combined);
        shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
        shapeRenderer.setColor(Color.RED);
        drawDebugBounds(Constants.MainMenuScreen.BUTTON_PLAY_NAME);
        drawDebugBounds(Constants.MainMenuScreen.BUTTON_QUIT_NAME);
        drawDebugBounds(Constants.MainMenuScreen.BUTTON_SETTINGS_NAME);
        shapeRenderer.end();
    }

    private void drawDebugBounds(String buttonName) {
        Rectangle bounds = getButtonBounds(buttonName);
        shapeRenderer.rect(bounds.x, bounds.y, bounds.width, bounds.height);
    }

    @Override
    public void resize(int width, int height) {
        super.resize(width, height);

        mainViewport.update(width, height, true);
        // mainViewport.getCamera().position.set( mainViewport.getCamera().viewportWidth / 2,  mainViewport.getCamera().viewportHeight / 2, 0);
        backgroundViewport.update(width, height, true);
        // backgroundViewport.getCamera().position.set( backgroundViewport.getCamera().viewportWidth / 2,  backgroundViewport.getCamera().viewportHeight / 2, 0);
        // stage.getViewport().update(width, height, true);
        setSkeletonScale(skeleton, Constants.MainMenuScreen.SKEL_WIDTH_PERCENTAGE, Constants.MainMenuScreen.SKEL_HEIGHT_PERCENTAGE);
        setSkeletonPosition(skeleton, mainViewport.getWorldWidth() / 2, mainViewport.getWorldHeight() / 2);
    }

    @Override
    public void dispose() {
        super.dispose();
        font.dispose();
        shapeRenderer.dispose();
    }
}
